## Copyright (C) 2012 Joel H. Levine#### Permission is hereby granted, free of charge, to any person obtaining## a copy of this software and associated documentation files (the "Software"),## to deal in the Software without restriction,including without limitation## the rights to use, copy, modify, merge, publish, distribute, sublicense,## and/or sell copies of the Software, and to permit persons to whom the Software## is furnished to do so, subject to the following conditions:#### The above copyright notice and this permission notice shall be included## in all copies or substantial portions of the Software.#### THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS## OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS## IN THE SOFTWARE.#Move to module:# Module file_readersfrom Tkinter import *import timeimport sys#-->sys.path.append("/Python-2.3.4/Numeric")#raw_input("in rectangle_driver")#008  Begin rewrite to more generic form:  Gather what has to be drawn before drawing.#     Then it should be 'relatively easy' to take that stuff and send it to Tkinter (at present)#     mathplotlib -- next, and whatever#     AND to use several of them at once.##     initial accumulation of image pieces to be drawn is in list 'im' constructed in net_plot_generic#     Even this is going to have conversion needs:  I think Tkinter draws circles from a center with a radius#     while matplotlib draws circles (or some figures) from lower left with widths and heights"""They all have drawbacks:TkinterTkinter is workable and produces ps output with true letters (as compared to instructions for drawing lines that look like letters)That makes it easy to edit and easy to scale.On the other hand, it wants to put it on the screen where, it seems, Apache objects.  I can turn off the screen byusing linux to redirect output.  But I haven't found a way to turn off screen access within the program, while keeping.ps file output.  (Redirecting  stdout, inside the program, doesn't turn off the screen drawing.It has a few troubles:  Edited in Illustrator, rescaling of labels often treats the last few letters of a labelas a different object.  It doesn't seem to depend on the length.  And when I had FORTRAN writing ps directly,Illustrator had the same problem.So Eric is writing his own software, creating the problem of maintaining two drawing routines -- and it isn't working well anywaythe dot images lack resolution.matplotlibmatplotlib  has the problem that it draws labels as dots or lines.  Illustrator can not recognize a whole word -- it isjust a collection of pieces among all the other 'stuff' on the graph.  To make it editable, I will have toeither/ormake each label a slightly different color, with differences invisible to the eye but visible to Illustratorand/or create a second set of images, one for row labels, one for column labels, etc..  The user can importthese to Illustrator drawing by drawing, as separate layers of one drawing.First try was too complicated.  Have to consider how it will be read and parsed.Second try very simple:(Is this forward Polish?  A kind of forward stack?  Maybe even reverse Polish.  Check ps manual forsuggestions)#parse 'line' with x0,y0,x1,y1=eval(line_of_text)line_colorblackline_width_pixels1file_color"#000fff000"unitsuserline0,0,2,3triangle_edge_in_user_x_units.1triangle_edge_in_inches.1triangle_origincentertriangle3,2"""#Color notes:  copied from quickref-Tkinter.pdf#3.3 Colors#	There are two general ways to specify colors in Tkinter.#  		You can use a string specifying the proportion of red, green, and blue in hexadecimal#		digits  (include the '#' sign):# 			#rgb 			Four bits per color#			#rrggbb 		Eight bits per color#			#rrrgggbbb 	Twelve bits per color#			#rrrrggggbbbb 	Sixteen bits per color#	For example, "#fff" is white, "#000000" is black, "#000fff000" is pure green,#	and "#00ffff" is pure cyan (green plus blue).#  	You can also use any locally defined standard color name. The strings "white",#	"black", "red", "green", "blue", "cyan", "yellow", and "magenta" will also#	be available. Others depending on your local installation.#	In my experience,  you can usually count on simple combinations,  e.g., blue, or lightblue, or darkblue.#         I've found that lots of named colors exist on my Mac, e.g., maroon.#       	If you need the whole color palette (or want to play with it), I have  the equivalent of a book of paint chips#	in my office.  It has the whole palette using "eight bits per color".  Nope, just checked.  It is met for the Web and#	the Web is not assumed to allow the complete palette.  #	In "hexadecimal," (arithmetic base sixteen rather than 10) digits are 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E, and F  (sixteen digits)#	So, for example, one of the pages of yellows#	shows   FFFFCC .  This  combines full red  (FF, a two digit hexadecimal),  full green (FF), and almost full blue (CC)#	This is a yellow so close to white that I can hardly see the difference.#	In sequence they get more intense (skipping some of the intermediate steps)#	FFFF99, FFFF66, FFFF33, FFFF00.  #          The last is a saturated yhellow#	The last on the page is CCCC00.  To my eye it has moved toward olive#          The book has 36 pages,  6 chips per page, 216 colors.  ("The book" is PANTONE Internet Color System Guide  (Colorweb), #	by Hayden books.  Expensive.#          The digitized colors are additive.  Thus, FFFFFF, has red, green, and blue at full intensity.  The result is white.#	 AAAAAA is a light grey.   And AAAAAD is almost the same light grey plus a  slight tinge of blue (where blue, at intensity#	 AD is slightly greater than the intensity of blue, AA, that built a light grey).  000000 is black.import sys#for item in sys.path:#	print item#-->sys.path.append("/Library/Frameworks/Python.framework/Versions/2.4/lib/python2.4/Numeric")#sys.path.append("/Python-2.3.4f/Lib/lib-tk")from Tkinter import *def readface(root_name):  	#Revised for Class        print "root_name is",root_name	# were it not for the use of a true numeric array, this could read text as well as numbers.  It would return a list of 'whatever'	#from Numeric import *	indata=open(root_name,"r")	#print indata.readline()	nrow=int(indata.readline())	ncol=int(indata.readline())	datamat=zeros((nrow,ncol),float)  #Float -- uppercase F, no quotation marks.	rlab=[]	clab=[]	row=0	col=0	print "nrow,row, ncol,col",nrow,row,ncol,col		while not (row==nrow and col==ncol):                #print "checking line AAA, nrow & ncol:",nrow,ncol		line=indata.readline()		line=line.replace("\r","")		line=line.replace("\n","")		line=line.strip()		line=line.split(",")		for i in xrange(len(line)): 			if line[i].strip()=="":  del line[i]		for entry in line:			datamat[row,col]=float(entry)			col+=1			if col==ncol:  				row+=1				col=0			if row==nrow and col==0:  break			if row==nrow and col==0:  break			#print "checking line BBB, nrow & ncol:",nrow,ncol	try:		for row in xrange(nrow):			line=indata.readline()			line=line.replace("\r","")			line=line.replace("\n","")			rlab.append(line.strip())	except:		print "error.   Problem reading row labels from file ",root_name		print "current row is ",row," nrow is ",nrow			try:					for col in xrange(ncol):			line=indata.readline()			line=line.replace("\r","")			line=line.replace("\n","")			clab.append(line.strip())		except:		print "error.   Problem reading columns labels from file ",root_name		print "current column is ",col," ncol is ",ncol				return nrow,ncol,datamat,rlab,clab		def readcoord(marker,n,cf):	#look for text marking a set of coordinates, somewhere in the file	#print "\ndebugA",cf[:1000]        #print "\ndebugB, looking for marker:",marker	pointer=cf.index(marker)	pointer+=1	filen=int(cf[pointer])	pointer+=1	filedim=int(cf[pointer])		coords=zeros((filen,filedim),float)	for row in xrange(filen):		for dim in xrange(filedim):			pointer+=1			coords[row,dim]=float(cf[pointer])	return coords,filedim				# Program:  rectangle_data_graphics_driver002.py# Program rectangle_driver001.py# for first writing put the driver and the "drivee" in here#-------------------------------------------#driver#from Numeric import *from numpy import *import random#From Python Scripting for Computational Science by Langtangen:#random.seed()	# set seed based on current time#random.seed(2198) # control the seed# print 'random number on (0,1):',   random.random()# print 'uniform random number on (-1,1):', random.uniform(-1,1)# print 'Normal(0,1) random number:', random.gauss(0,1)# from ... Absolute Beginner# random.randrange(left_bound,right_bound) # random integer within specified range#random.seed(2198)class Linear_transform(object):	""" Transform user's coordinates into window coordinates"""	def __init__(self,init_intercept,init_slope):		self.intercept=init_intercept		self.slope=init_slope	def pixel(self,xx):		p=self.intercept+self.slope*xx		#print "intercept,slope,xx,p",self.intercept,self.slope,xx,p		return p			def outlrbt(nrow,ncol,rx,cx):  #assume driver sent two dimensions, with rx ('row coordinates') and cx('column coordinates')		""" Compute extremes that will be assigned to the graphical output.  Some of these will exceed	 empirical extremes.  This will make a square look like a square and allow labels to extend 	 to the right of the rightmost point and still be inside the graphical output."""		#Calculate the extremes of the canvas expressed in units of the user's problem	#As for a map, assume that a unit interval in the vertical dimension has the	#same visual extent as a unit interval in the horizontal dimension		x_left,x_right,y_bottom,y_top=lrbt(nrow,ncol,rx,cx)  #extremes combining two sets of coordinates.  Each set is two dimensional	#Extend slightly because it cuts so tightly that it leaves off the first pixel of a text	x_range=x_right-x_left	#print "x_left=",x_left	x_left-=x_range/50.	x_right+=x_range/10.	#print "x_left=",x_left		y_range=y_top-y_bottom	y_top+=y_range/20.	y_bottom-=y_range/30.	# Adopting code from mobil19graphicsSethKldg.5	# old code modifies for aspect ratio and to allow room for labels	# assume 11 x 8.5 paper.  Subtract half inch for each margin		hv_aspect_ratio=(10-.5)/7.5  #landscape paper page,  half inch blank to right allows room for labels extending beyond right-most point. 	#hv_aspect_ratio=(10-1)/7  #landscape paper page,  half inch blank to right allows room for labels extending beyond right-most point. 	x_range=x_right-x_left	y_range=y_top-y_bottom	xy_aspect_ratio=x_range/y_range	xyratio_over_hvratio=xy_aspect_ratio/hv_aspect_ratio	# compare coordinate ratio to horizontal-vertical visual output ratio.  Reconcile them.	if xy_aspect_ratio>hv_aspect_ratio:  # wants wider screen or shorter screen.  Make shorter		# Add blank space (i.e., space beyond the range of the data)  to the bottom and top		added=y_range*xyratio_over_hvratio - y_range		y_top+=(1./3.)*added		y_bottom-=(2./3.)*added	else:		# Add blank space to the left and right		added=x_range/xyratio_over_hvratio - x_range		x_right+=.5*added		x_left-=.5*added			return x_left,x_right,y_bottom,y_top		def lrbt(nrow,ncol,rx,cx):	coord_left=min(min(rx[0:nrow,0]),min(cx[0:ncol,0]))	coord_bottom=min(min(rx[0:nrow,1]),min(cx[0:ncol,1]))	coord_right=max(max(rx[0:nrow,0]),max(cx[0:ncol,0]))	coord_top=max(max(rx[0:nrow,1]),max(cx[0:ncol,1]))	#print coord_left,coord_right,coord_bottom,coord_top,"coordinate limits"			return coord_left,coord_right,coord_bottom,coord_topdef dot(x,y,dkey,options_dictionary):	global x_locate, y_locate, canvas #, options_dictionary	outline_color=options_dictionary['fill_color']  # Here 'fill' is actually the outline	x_pixel=x_locate.pixel(x)	y_pixel=y_locate.pixel(y)		r=7  	#radius of circle	canvas.create_oval(x_pixel-r,y_pixel-r,x_pixel+r,y_pixel+r,width=2,fill='',outline=outline_color)	def square(x,y,dkey,options_dictionary):	global x_locate, y_locate, canvas #, options_dictionary	outline_color=options_dictionary['fill_color']  # Here 'fill' is actually the outline	x_pixel=x_locate.pixel(x)	y_pixel=y_locate.pixel(y)		r=4  	#"radius" of square (half its width)	canvas.create_rectangle(x_pixel-r,y_pixel-r,x_pixel+r,y_pixel+r,width=1.25,fill='',outline=outline_color)  #the square	canvas.create_rectangle(x_pixel-.25,y_pixel-.25,x_pixel+.25,y_pixel+.25,fill='black',outline='black',width=2) #the dot in the center of squaredef height_rectangle(x,y,height,dkey,options_dictionary):	global x_locate, y_locate, canvas #, options_dictionary	outline_color=options_dictionary['fill_color']  # Here 'fill' is actually the outline	x_pixel=x_locate.pixel(x)	y_pixel=y_locate.pixel(y)		#r=4  	#"radius" of square (half its width)	r=.5	if height>=0:                canvas.create_rectangle(x_pixel-3*r,y_pixel-height*40,  x_pixel-r, y_pixel,width=1.0,fill="",outline="#33CC00") #'green')        else:                canvas.create_rectangle(x_pixel-3*r,  y_pixel,          x_pixel-r, y_pixel-height*40,width=.25,fill="",outline='red')	#canvas.create_rectangle(x_pixel-r,y_pixel-r,x_pixel+r,y_pixel+r,width=1.25,fill='',outline=outline_color)  #the square	#canvas.create_rectangle(x_pixel-.25,y_pixel-.25,x_pixel+.25,y_pixel+.25,fill='black',outline='black',width=2) #the dot in the center of squaredef triangle(x,y,dkey,options_dictionary):	global x_locate, y_locate, canvas	outline_color=options_dictionary['fill_color']  # Here 'fill' is actually the outline		x_pixel=x_locate.pixel(x)	y_pixel=y_locate.pixel(y)		r=6  	#"radius" of square (half its width)			#canvas.create_polygon(x_pixel-r,y_pixel+r*.5*1.732, x_pixel+r,y_pixel+r*.5*1.732,	#		x_pixel,y_pixel-r*.5*1.732,width=2,fill='',outline=outline_color)	cos30=.866	sin30=.5	canvas.create_polygon(x_pixel,y_pixel-r,  x_pixel+r*cos30,y_pixel+r*sin30,			x_pixel-r*cos30,y_pixel+r*sin30, x_pixel,y_pixel-r,width=1.25,fill='',outline=outline_color)def line(begin_x,begin_y,end_x,end_y,dkey,options_dictionary):	global x_locate	global y_locate	global canvas		fill_color=options_dictionary['fill_color']	line_width=options_dictionary['line_width']	bx=x_locate.pixel(begin_x)  # input valued (user's units) transformed to pixel units (I'd prefer inches)	by=y_locate.pixel(begin_y)	ex=x_locate.pixel(end_x)	ey=y_locate.pixel(end_y)	canvas.create_line(bx,by,ex,ey,fill=fill_color,width=line_width)	def text_line(x,y,tex,dkey,options_dictionary):	global x_locate	global y_locate	global canvas		#global options_dictionary		fill_color=options_dictionary['fill_color']	if 'font' in options_dictionary:                font=options_dictionary['font']                canvas.create_text(x_locate.pixel(x),y_locate.pixel(y),text=tex,fill=fill_color,font=font,anchor='sw')        else:                canvas.create_text(x_locate.pixel(x),y_locate.pixel(y),text=tex,fill=fill_color,anchor='sw')	def draw_axes(left,right,bottom,top,options_dictionary):	line(left,0,right,0,"Axis",options_dictionary)	line(0,bottom,0,top,"Axis",options_dictionary)def set_up(x_left,x_right,y_bottom,y_top):	#use these two to get pixel positions, 72 pixels per inch, origin at upper left	global x_locate   #makse the specific instance of a linear tranf available globally.  	global y_locate   #makes this differently defined linear transform available globally.	#use these two to get users x and y from inches, origin in inches at lower left	#If I want a label at the left, 1/4 inch in and 1/4 inch above the bottom, this gives me its location in x and y	#hmmmm... it is more of a problem getting it at some number of inches from the top	#hmmmm again:  matplotlib is workable after all.  It specifies image size in inches	#          and I think it figures out the range of whatever user units it is asked to graph in that inches-sized window	#           so I'm going to have to convert both from and too inches	global inches_from_bottom_to_y  #converts inches up from bottom into user's x units	global inches_from_top_to_y     #converts inches below top to y units	global inches_from_left_to_x	global inches_from_right_to_x	#matplot lib seems to have an origin at lower left and adopt the user's units (while squeezing them into an image in inches	#So I'll need some correspondence between size in pixels, as used in the present Tkinter code, and size in inches	#Probably best to make inches the basic definition and transform them into pixels for images drawn by the Tkinter code.	#These were determined elsewhere.  I need them here	global forced_width	global forced_height        """        Pixel frame                                        |         Problem unit frame                                                           |        (0,0)               (forced_width,0)               |         (x_left,y_top)         (x_right,y_top)                                                                    |                                                           |        (0,-forced_height)  (forced_width,-forced_height)  |         (x_left,y_bottom)      (x_right,y_bottom)------------------------------------------------------------------------------------------------------------        Transformation for horizontal coordinate in pixels as a function of the user's problem units in x                 |forced_width                                                  .           |                                              .     |         |                                      .             |rise         |                            .                       |0________|____________________._______________________________|         |              .     |           run         |        .           |         |   .                |intrcpt  .____________________|         |    -----0--------------------x_left--------------------------x_right----  user x                slope of the conversion line is (rise/run), which is forced_width/(x_right -x_left)                                intercept of the conversion line is the value of the conversion line at x=0                That is zero minus x_left*slope------------------------------------------------------------------------------------------------------------        Transformation for the vertical coordinate in pixels as a function of the user's problem units in y0        |                                                    .           |                                              .     |         |                                      .             |rise         |                            .                       |-forced_height <--------------.<----------------------------->         |              .     ^           run                 |         |        .           |                               |         |   .                |                               |intrcpt__.____________________|_______________________________|         |    -----0--------------------y_bottom----------------------y_top----  user y                slope of the conversion line is (rise/run), which is [0-(-forced_height)]/(y_top - y_bottom)                                intercept of the conversion line is the value of the conversion line at y=0                That is  0 - y_top*slope------------------------------------------------------------------------------------------------------------"""	        #squaring off, so that a one unit, left to right, looks like one unit bottom to top                # squaring off makes a square look like a square not a rectangle                # This squaring off appears to be accomplished somewhere else (probably by stretching the range of the problem units        #These two user to pixel transformation functions become available (globally) for use throughout the program.                	#width in problem units converted to width in pixels	#left edge in porblem unit converted to left edge (zero) in pixels	m1=float(forced_width)/(x_right-x_left)  #for the moment, 500 wide, 400 high	b1=-x_left*m1	x_locate=Linear_transform(b1,m1)  #creates a class instance whose method is a specific linear transformation        #height in problem units convert to height in pixels	#bottom in problem units convert to botto (	m2=-float(forced_height)/(y_top-y_bottom)	b2=-y_top*m2	y_locate=Linear_transform(b2,m2)  #creates a different class instance whose method is a different linear transformation	#assume 72 pixels per inch.  Actually this is not a safe assumption.  See note at bottom of this method	#m3=forced_width/(        #using x and y to refer to user units.  A sane user will put the origin at the lower left, x is horizontal, y vertical        #LLpixels_from_x  origin at Lower Left not written.  Is it needed?        #LLpixels_from_y"        #ULpixels_from_x  needed for Tkinter        #ULpixels_from_y                                                """On Sun, 30 Mar 2008 15:37:35 +0200Fredrik Lundh <fredrik at pythonware.com> wrote:> Ron Provost wrote:> > > Is there any way in tkinter to convert between coordinate systems?  > > Specifically, I'm refering to the canvas.  I'm getting x and y's back in > > mouse events and I would like to convert them back to inches 'i', > > centemeters 'c', millimeters 'm' or points 'p'.> > use winfo_screenheight() and winfo_screenmmheight() to determine the > pixel size, and use that to calculate "real-life" values.  e.g.> > 	pixel_size =   w.winfo_screenmmheight() / w.winfo_screenheight()> > 	...> > 	x = x * pixel_size> 	print x, "mm"> 	print x/10.0, "cm"> 	print x/25.4, "inches"> 	print 72*x/25.4, "points"> You should be aware however that the values reported by winfo_screenmmheight()and winfo_screenmmwidth() may be incorrect; I think this is because tk assumesa screen dpi value of 72 which may be different from what the system actuallyuses. For example my debian etch system uses a dpi value of 96 by default, so when I call    w.winfo_screenmmheight()tk returns 203 where the actual value should be 203 * (96 / 72) = 270 .You can query the dpi value in use with     w.winfo_fpixels('1i')which returns on my box: 95.976383763837632You can even force tk to use a dpi value different from the system default:    w.tk.call('tk', 'scaling', '-displayof', '.', your_dpi_value / 72.0)which may be useful if you want to make sure that for example some Canvas itemsare drawn in an exact mm-size onto the user's screen (however be careful, doingso might mess up the application's visual appearance on some systems, especiallyusing point-sized fonts should be avoided).Hope this helpsMichael"""#The sort of version produces both meta_plot and Tkinter.  But some of the Tkinter disappeared -- it isn't drawing the lines        #and I never checked the height rectangles.        #Maybe I need pidgin_plot that uses the present calls (that eventually call Tkinter) -- but generates the meta_code instead of        #calling Tkinter        #Now make a third copy of net_plot and slowly re-introduce the new stuff until I find the bug.def net_plot_sort_of(nrow,ncol,rx,cx,data,rlab,clab,outf,options_dictionary,pause_between_drawings=False):        #raw_input("entering test version of net_plot with filing")        """        If I get this right then execution should involve preloading a function dictionary with functions and then running through the        list in order        line_color        black        line_width        1        4tuple        1,2,5,4        line        executes:        for i in range(...)            if list[i] not in function_dictionary:                command_dictionary[list[i]]=list[i+1]            else:                        function_dictionary[lis[i]]        Can I load the function dictionary not only with calls but with the names of their arguments        e.g. function_dictionary['line']=line(4tuple)                """        #The original work appears to use primarily two units:  user's PROBLEM units in pounds dollars or whatever        #  and plotable pixel units, assuming        #        origin is at upper left        #                        #divide the work to facilitate changes in the actual graphics vehicle        #Here we prepare just a long list of lines, figures, texts, ... whatever        #with descriptions and specifications, to be drawn in order.        im=[]             #options_dictionary={}): #originally is was created here but used values from main.  Now, with entry, it can be created there (and             #hold things that were previously global.  (Global is now not easily defined).	#raw_input("top of net_plot")	#from Tkinter import *	global canvas	global forced_width	global forced_height		if not options_dictionary:                options_dictionary={}	options_dictionary['fill_color']='black' #for lines and interiors of figures (Use common colors or '' for transparent)        im.append("fill_color\n'black'")	options_dictionary['line_width']=1        #for lines        im.append("line_width\n1")         	im.append("line_width_in_pixels\n"+str(options_dictionary['line_width']))	im.append("fill_color\n"+str(options_dictionary['fill_color']))        force_one_dim=False  #Kludge for 1 dim. Use both dims (same) for setup.  then draw only 1 (0 for other)	if options_dictionary['pairs_to_draw']:                pr=options_dictionary['pairs_to_draw']                if pr[0][0]==pr[0][1]:  force_one_dim=True		# QUESTION:  THE PROGRAM PARTIALLY IGNORES THE NEXT LINE IF I USE IT.  IT INSTANTIATES canvas, BUT IT IGNORES	#THE WIDTH AND HEIGHT	#canvas=Canvas(width="10.1i",height="7.5i",bg='white') #canvas , size in inches		#forced_height=700		forced_height=600 #500 #change to 700 had no effect.  Where is the right change?	forced_width=1.2666*forced_height   # force aspect ratio of 10 by 7.5  (11 by 8.5 paper minus half inch margins  (1200        im.append("image_height_in_pixels\n"+str(forced_height))        im.append("image_width_in_pixels\n"+str(forced_width))        im.append("image_height_in_inches\n"+str(forced_height/72.))        im.append("image_width_in_inches\n"+str(forced_width/72.))                  	#canvas=Canvas(width=500,height=400,bg='white') #canvas , size in pixels##	try:##                canvas.pack_forget##        except:##                pass	try:                if canvas:                        canvas=""                        #raw_input("Canvas nulled")        except:                pass        #display image in pixels	canvas=Canvas(width=forced_width,height=forced_height,bg='white') #canvas , size in pixels        im.append("background_color\n'white'")	canvas.pack(expand=YES,fill=BOTH)  #coordinates in pixels.  0,0 at upper left.  x increases left to right.  y increases high to low (upside down)		#print "test info:"	#print "height",canvas.winfo_height()	#print "width ",canvas.winfo_width()	#print tk.winfo_height()	#print tk.winfo_width()	#ODD:  If I remove the following raw input, then it does not correctly put the files in the folder.	#raw_input("700 by "+str(1.2666*700)+"? Press ENTER to continue.")  #PROBLEM:  It is returning  1   and   1    .	#print "700 by "+str(1.2666*700)+" #? Press ENTER to continue."  #PROBLEM:  It is returning  1   and   1    .		# Compute extremes that will be assigned to the graphical output.  Some of these will exceed	# empirical extremes.  This will make a square look like a square and allow labels to extend 	# to the right of the rightmost point and still be inside the graphical output.	cx_left,cx_right,cy_bottom,cy_top=outlrbt(nrow,ncol,rx,cx) # canvas left,...	im.append("square_and_label_adjusted_user_unit_extreme_left\n"+str(cx_left))	im.append("square_and_label_adjusted_user_unit_extreme_right\n"+str(cx_right))	im.append("square_and_label_adjusted_user_unit_extreme_bottom\n"+str(cy_bottom))	im.append("square_and_label_adjusted_user_unit_extreme_top\n"+str(cy_top))		true_left,true_right,true_bottom,true_top=lrbt(nrow,ncol,rx,cx)	im.append("user_coordinates_extreme_left\n"+str(true_left))	im.append("user_coordinates_extreme_right\n"+str(true_right))	im.append("user_coordinates_extreme_bottom\n"+str(true_bottom))	im.append("user_coordinates_extreme_topt\n"+str(true_top))			#Put extremes computed for canvas into the canvas.	set_up(cx_left,cx_right,cy_bottom,cy_top)			#Grid	# For my applications the range is pretty reliably within +- 3.  Just mark integer grid        im.append("Comment\nlightblue grid lines")	options_dictionary['line_width']=1	options_dictionary['fill_color']='lightblue'        im.append("fill_color\n'lightblue'")	im.append("line_width_in_pixels\n"+str(options_dictionary['line_width']))	im.append("fill_color\n"+str(options_dictionary['fill_color']))                          #If the total range is small, less than 3, then impose a fine grid	#at .1's        #print "true_right,true_left",true_right,true_left        #print "true_top,true_bottom",true_top,true_bottom        im.append("GROUP\nlight grid line")        print "debug true_right, true_left",true_right,true_left        raw_input("debug 698 true+right-true+left="+str(true_right-true_left))	if true_right-true_left<4:                raw_input("debug refine grid at 699")                im.append("GROUP\ngrid_line")                for h in arange(int(true_left-.5),int(true_right+.5),1):                        line(h,true_top,h,true_bottom,"junk",options_dictionary)                for h in xrange(10*int(true_left-.5),10*int(true_right+.5)+1):                        if h/10.>=true_left and h/10.<= true_right:                                line(h/10.,true_top,h/10.,true_bottom,"junk",options_dictionary)                                im.append("line\n["+str(h/10.)+","+str(true_top)+","+str(h/10.)+","+str(true_bottom)+"]")                for v in xrange(int(10*(true_bottom-.6)),int(10*true_top+.5)):                        if v/10.>=true_bottom and v/10.<=true_top+.1:                                line(true_left,v/10.,true_right,v/10.,"junk",options_dictionary)                                im.append("line\n["+str(true_left)+","+str(v/10.)+","+str(true_right)+","+str(v/10.)+"]")                                 options_dictionary['fill_color']="#7777FF"  #somewhat darker blue        im.append("GROUP\ndarker grid line")          	im.append("fill_color\n"+str(options_dictionary['fill_color']))		for h in xrange(int(true_left-.5),int(true_right+.5)+1):		if h>=true_left and h<= true_right:                        line(h,true_top,h,true_bottom,"junk",options_dictionary)                        im.append("line\n["+str(h)+","+str(true_top)+","+str(h)+","+str(true_bottom)+"]")	for v in xrange(int(true_bottom-.6),int(true_top+.5)+1):                if v>=true_bottom and v<=true_top:                        line(true_left,v,true_right,v,"junk",options_dictionary)                        im.append("line\n["+str(true_left)+","+str(v)+","+str(true_right)+","+str(v)+"]")			#Axes        im.append("GROUP\naxes")	options_dictionary['fill_color']='darkblue'        im.append("fill_color\n'darkblue'")	options_dictionary['line_width']=1	im.append("line_width_in_pixels\n"+str(options_dictionary['line_width']))	im.append("fill_color\n"+str(options_dictionary['fill_color']))	im.append("['line',[true_left,true_right,true_bottom,true_top],'DRAWING_GROUP:  AXIS']")	im.append("line\n["+str(true_left)+","+str(true_right)+","+str(true_bottom)+","+str(true_top)+"]")	#line(true_left,0,true_right,0,"junk")	#line(0,true_bottom,0,true_top,"junk")										#OOPS -- grid is not looking squared:  check:	#options_dictionary['fill_color']='red'	#line(-1,1,1,1,'junk')	#line(1,1,1,-1,'junk')	#line(1,-1,-1,-1,'junk')	#line(-1,-1,-1,1,'junk')	#text_line(-1,1,"This should look square","junk")				#four line box  (Used for practice.  These could be replaced by drawing a box directly)	#options_dictionary['fill_color']='black'	#options_dictionary['line_width']=1	#line(cx_left,cy_top,cx_right,cy_top,"junk")	#line(cx_right,cy_top,cx_right,cy_bottom,"junk")	#line(cx_right,cy_bottom,cx_left,cy_bottom,"junk")	#line(cx_left,cy_bottom,cx_left,cy_top,"junk")				#text_line(0,0,str(nrow)+" rows "+str(ncol)+" columns","junk")        im.append("GROUP\nlinks")		#draw lines first.  This puts them visually under everything else	options_dictionary['fill_color']=options_dictionary['line_color']   #global variable determined in main (default 'grey')	#options_dictionary['line_width']=.1	options_dictionary['line_width']=.2	im.append("line_width_in_pixels\n"+str(options_dictionary['line_width']))	im.append("fill_color\n"+str(options_dictionary['fill_color']))	if options_dictionary['draw_lines']:		for row in xrange(nrow):			begin_x=rx[row,0]			begin_y=rx[row,1]			for col in xrange(ncol):				if data[row,col]>0:					end_x=cx[col,0]					end_y=cx[col,1]					if not force_one_dim:                                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                                im.append("line\n["+str(begin_x)+","+str(begin_y)+","+str(end_x)+","+str(end_y)+"]")                                        else:                                                if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                line(m,begin_y,m,end_y,"link",options_dictionary)	                                                im.append("line\n["+str(m)+","+str(begin_y)+","+str(m)+","+str(end_y)+"]")			#raw_input("RETURN to continue")			#draw locations of rows and name them	#print "\n\nfor debugging:  these items are presently associated with a color"	#ck=text_color_dictionary.keys()	#ck.sort()	#for cki in ck:  print cki,len(cki),	#print "\n\n"	nfound=0	nnotfound=0		for row in xrange(nrow):		options_dictionary['fill_color']='red' #'maroon'		im.append("fill_color\n'red'")		if options_dictionary['icons']:                        im.append("GROUP\nrow_icons")                        im.append("triangle_size\nunknown")                        if not force_one_dim:                                #can not call my triangle method for help (by letting it add to im) because it is                                #already thinging in Tkinter specifics.  Specifically, it converts to pixels                                #So, I'll need to have each new graphics set have its own triangle routine                                im.append("triangle\n["+str(rx[row,0])+", "+str(rx[row,1])+"]")                                triangle(rx[row,0],rx[row,1],"row_point",options_dictionary)                        else:                                        if cx_left<0 and cx_right>0:                                        m=0                                else:                                                m=(cx_left+cx_right)/2                                im.append("triangle\n["+str(m)+", "+str(rx[row,1])+"]")                                triangle(m,rx[row,1],"row_point",options_dictionary)##                if 'row_heights' in options_dictionary:##                        #raw_input("at A, row_heights in options_dictionary")##                else:##                        #raw_input("at A,  row_heights NOT IN options_dictionary")                                        if 'row_heights' in options_dictionary:  #if it is in the dictionary                        if options_dictionary['row_heights']==True: #and not 'False' Mere presence in dict yields True                                im.append("GROUP\nrow_heights")                                print "row heights",options_dictionary['row_heights']                                raw_input("it thinks row_heights is in options_dictionary")                                if options_dictionary['row_heights']:                                        row_height_positive=[]                                        #raw_input("at b,")                                                                                if not force_one_dim:                                                height_rectangle(rx[row,0],rx[row,1],options_dictionary["row_heights"][rlab[row].strip()],"row_point",options_dictionary)                                                im.append("height_rectangle\n["+str(rx[row,0])+","+str(rx[row,1])+","+ str(options_dictionary["row_heights"][rlab[row].strip()])+"]")                                                      if options_dictionary["row_heights"][rlab[row].strip()]>0: row_height_positive.append(row)                                        else:                                                        if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                triangle(m,rx[row,1],"row_point",options_dictionary)                                                im.append("triangle\n["+str(m)+", "+str(rx[row,1])+"]")            		options_dictionary['fill_color']='darkred' #'maroon'                im.append("fill_color\n'darkred'")                                         		default='darkred'		rlab_row=rlab[row].strip()		extra_info=[]				while "<" in rlab_row:			#print rlab_row,row			#raw_input("check for <")			left=rlab_row.index("<")			#print "rlab_row|"+rlab_row+"|"			#print "left",left			try:				right=rlab_row,index(">",left)  #??? this is not picking up a terminal '>'				ext=rlab_row[left+1:right]				#print "found right >",right    #??? 			except:				#right=len(rlab_row)				ext=rlab_row[left+1:len(rlab_row)-1]					#print "did not fine right >",right			rlab_row=rlab_row[:left].strip()								#ex=rlab_row[left+1:right]			#print "ex:  ",ex								if color_from_bracket:  extra_info.append(ext)			if color_from_name:extra_info.append(rlab_row)			print "extra_info:",extra_info						if len(extra_info)>0:				options_dictionary['fill_color']=default				im.append("fill_color\n"+str(options_dictionary['fill_color']))				for elt in extra_info:					#print "elt=",elt					#print "...dict",text_color_dictionary[elt]					if elt in text_color_dictionary:						options_dictionary['fill_color']=text_color_dictionary[elt]                                                im.append("fill_color\n"+str(options_dictionary['fill_color']))						##		if options_dictionary['color_from_name']:  ##			rl=rlab_row.strip()##			rl=rl.upper()##			if rlab_row.strip().upper() in text_color_dictionary:##				#options_dictionary['fill_color']=text_color_dictionary[rlab_row.strip()]	##				options_dictionary['fill_color']=text_color_dictionary[rl]	##				nfound+=1			##			else:##				nnotfound+=1##				#not used##				#print "This label is not in the coloring instructions:  <"+rlab_row.strip()+"> length",len(rlab_row.strip()),nfound,"/",nnotfound####                                #removed from Eric version##				#print "This label is not in the coloring instructions:  <"+rl+"> length",len(rl),nfound,"/",nnotfound##				nnotfound+=1					if not force_one_dim:                                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                                im.append("GROUP\nlink")                                                im.append("line\n["+str(begin_x)+","+str(begin_y)+","+str(end_x)+","+str(end_y)+"]")                                        else:                                                if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                line(m,begin_y,m,end_y,"link",options_dictionary)	                                                im.append("GROUP\nlink")                                                im.append("line\n["+str(m)+","+str(begin_y)+","+str(m)+","+str(end_y)+"]")									if not force_one_dim:                        if 'row_heights' in options_dictionary:                                if options_dictionary['row_heights']==True:                                        if options_dictionary['row_heights']==True:                                                #raw_input("CCC")                                                restore_fill_color=options_dictionary['fill_color']                                                if row in row_height_positive:                                                        #raw_input("DDD")                                                        options_dictionary['fill_color']='#009900' #'green'                                                else:                                                        #raw_input("EEE")                                                        options_dictionary['fill_color']='red'                                                #raw_input("FFF")                                                im.append("GROUP\nrow_label")                                                        im.append("fill_color\n"+str(options_dictionary['fill_color']))                                                        text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                                                im.append("text\n["+str(rx[row,0])+","+str(rx[row,1])+",'"+str(rlab[row])+"']")                                                options_dictionary['fill_color']=restore_fill_color                                                im.append("fill_color\n"+str(options_dictionary['fill_color']))                                        else:                                                im.append("GROUP\nrow_label")                                                im.append("text\n["+str(rx[row,0])+","+str(rx[row,1])+",'"+str(rlab[row])+"']")                                        text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                else:                                if cx_left<0 and cx_right>0:                                m=0                        else:                                        m=(cx_left+cx_right)/2                        im.append("GROUP\nrow_label")                                im.append("text\n["+str(rx[row,0])+","+str(rx[row,1])+",'"+str(rlab[row])+"']")                        text_line(m,rx[row,1],rlab[row],"row_label",options_dictionary)                        		#triangle(rx[row,0],rx[row,1],"row_point")		##########FUDGE#TO DROP WORDS#############text_line(rx[row,0],rx[row,1],rlab_row,"row_label")	#print "\ndebugging color from labels:   Found ",nfound,"  not Found ",nnotfound,"\n"	if not options_dictionary['square_table']:		#draw locations of columns and name them		for col in xrange(ncol):			options_dictionary['fill_color']='green'			im.append("fill_color\n'green'")			if options_dictionary['icons']==True:                                if not force_one_dim:                                        square(cx[col,0],cx[col,1],"col_point",options_dictionary)                                else:                                                if cx_left<0 and cx_right>0:                                                m=0                                        else:                                                        m=(cx_left+cx_right)/2                                        square(m,cx[col,1],"col_point",options_dictionary)                                			options_dictionary['fill_color']='blue'  #avoid red/green color blindness			im.append("fill_color\n'blue'")			default='blue'			clab_col=clab[col].strip()			extra_info=[]						while "<" in clab_col:				left=clab_col.index("<")				try:					right=clab_col,index(">",left)  #??? this is not picking up a terminal '>'					ext=clab_col[left+1:right]				except:					ext=clab_col[left+1:len(clab_col)-1]						#print "did not fine right >",right				clab_col=clab_col[:left].strip()										extra_info.append(ext)				if len(extra_info)>0:					options_dictionary['fill_color']=default					for elt in extra_info:						if elt in text_color_dictionary:							options_dictionary['fill_color']=text_color_dictionary[elt]							im.append("fill_color\n'"+options_dictionary['fill_color']+"'")			                        if not force_one_dim:                                text_line(cx[col,0],cx[col,1],clab_col,"col_label",options_dictionary)                                im.append("GROUP\ncol_label")                                im.append("text\n["+str(cx[col])+","+str(cx[col,1])+",'"+clab_col+"']")                        else:                                        if cx_left<0 and cx_right>0:                                        m=0                                else:                                                m=(cx_left+cx_right)/2                                text_line(m,cx[col,1],clab_col,"col_label",options_dictionary)                                im.append("GROUP\ncol_label")                                im.append("text\n["+str(m)+","+str(cx[col,1])+",'"+clab_col+"']")        if 'draw_column_sequence' in options_dictionary:                #print options_dictionary["draw_column_sequence"]                #raw_input("dcs in net_plot before drawing2")                    if options_dictionary['draw_column_sequence']:                                                #print type(options_dictionary["draw_column_sequence"])                        #raw_input("dcs in net_plot before drawing3")                            restore_fill_color=options_dictionary['fill_color']                        restore_line_width=options_dictionary['line_width']                                                options_dictionary['fill_color']='dark blue'                        options_dictionary['line_width']=2.3                        im.append("fill_color\n'dark blue'")                        im.append("line_width_pixels\n2.3")                        #Try from deep green to light light, where light is the leading edge                        #cs=['#000000','#001100','#002200','#003300','#004400','#005500','#006600','#007700','#008800','#009900'] #10 brightness shade of green                        #Too many shades make it hard to select during Illustrator editing                        cs=['#AA0000','#666600','#00AA00']                         #stp=int(ncol/len(cs))                        conversion_slope=(len(cs)/float(ncol))                        for col in xrange(ncol-1):                                #print "col",col,"len(cs)",len(cs),"int(col*conversion_slope)",int(col*conversion_slope)                                options_dictionary['fill_color']=cs[int(col*conversion_slope)]                                im.append("fill_color\n'"+options_dictionary['fill_color']+"'")                                ##switch to two colors, using green for last month (last 5 data points)                                #if col>=ncol-4:                                #        options_dictionary['fill_color']="#44BB00"                                #else:                                #        options_dictionary['fill_color']="#5555BB"                                begin_x=cx[col,0]                                begin_y=cx[col,1]                                end_x=cx[col+1,0]                                end_y=cx[col+1,1]                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                im.append("GROUP\nlink")                                im.append("line\n["+str(begin_x)+","+str(begin_y)+","+str(end_x)+","+str(end_y)+"]")                                #print clab[col],clab[col+1]                        options_dictionary['fill_color']=restore_fill_color                        options_dictionary['line_width']=restore_line_width                        im.append("fill_color\n'"+options_dictionary['fill_color']+"'")                        im.append("line_width_pixels\n"+str(options_dictionary['line_width']))        draw_out=open("meta_graph","w")        for item in im:                draw_out.write(item+"\n")        draw_out.close()        		        #print "before ps, file is",outf			#canvas.postscript(file=outf) #(file="rectangle_out"+str(pcount))        #raw_input("debug, filing"+outf)                        	canvas.postscript(file=outf,width=1.6*forced_width,height=1.25*forced_height,rotate=False,x=-.5*forced_width) #(file="rectangle_out"+str(pcount))	#sys.outf.flush()	#print "after ps"	#ppss=canvas.postscript()	#jk=open("junk","w")	#jk.write(ppss)	#print "Saving  'rectangle_out', a  postscript format output file."        #print "Saving  "+outf+", a  postscript format output file."        #time.sleep(10)        #raw_input("pause between drawings="+str(pause_between_drawings))        #time.sleep(5)        #print "*"        pause_between_drawings=True	if pause_between_drawings:                #time.sleep(15)                canvas.pack(expand=YES,fill=BOTH)  #coordinates in pixels.  0,0 at upper left.  x increases left to right.  y increases high to low (upside down)                canvas.update()                #print "*"*40  #It seems to want to go back to screen before producint the actual plot                #raw_input("WAIT for- image to be drawn.  Then press RETURN to contine to next image or to close the program.")                #time.sleep(5)        #Tcl.quit()        if options_dictionary['clean_up']:  #default                #print "cleanup-----------------------------------"                canvas.pack_forget()  #Why is this not leaving a momentarily blank screen?                canvas.destroy()class Pidgin_plot(object):        def __init__(self):                self.im=[]                                #self.options={}  #not necessary for writing im.  (It will be useful in the program that reads im and translates to plot commands)        def options(self,variable_name,value):                self.im.append(variable_name)                self.im.append(value)        #def add(lis):        #        for item in lis:        #                self.im.append(item)##        def update_options(self,options_dictionary):##                for k in options_dictionary:##                        self.im.append(str(k)+"\n"+str(options_dictionary[k]))        def save(self,file_name):                fn=open(file_name,"w")                for item in self.im:                        fn.write(str(item)+"\n")                fn.close()        def comment(self,s):                self.im.append("COMMENT")                self.im.append(str(s))        def line(self, x0,y0, x9,y9, group=False,options_dictionary=False):                if group:                        self.im.append("GROUP")                        self.im.append(str(group))                self.im.append("line")                self.im.append("["+str(x0)+","+str(y0)+","+str(x9)+","+str(y9)+"]")        def triangle(self,x,y,r=.1):   #draw a triangle inscribed in a circle of radius r                #don't worry about implementing it.  That's for whomever deals with the output                #preparing for a specific application.                #self.line(self,x,y+r, cos(r*pi/6.),-sin(r*pi/6), group="Column Icon",color=self.options(line_color)) #how can I fill it? Need a polygon fill                #self.line(self,cos(r*pi/6.),-sin(r*pi/6), -cos(r*pi/6.),-sin(r*pi/6), group="Column Icon",color=self.options(line_color)) #how can I fill it? Need a polygon fill                #self.line(self,-cos(r*pi/6.),-sin(r*pi/6), x,y+r, group="Column Icon",color=self.options(line_color)) #how can I fill it? Need a polygon fill                self.im.append("radius")                self.im.append(str(r))                self.im.append("triangle")                self.im.append("[str(x),str(y)]")        def text_line(self,x,y,tex,group,options_dictionary):                self.im.append("text_line")                self.im.append('[x,y,'+tex+']')                                                                                              ##        def draw_axes(self,left,right,bottom,top):##        ##                self.line(left,0,right,0,"Axis")##	im.append("line:  "+str(left,0,right,0)+"DRAWING_GROUP:  Axis")  #the 'if' keeps it compatible with currently running coe##	line(0,bottom,0,top,"Axis",options_dictionary)##	im.append("line:  "+str(0,bottom,0,top)+"DRAWING_GROUP:  Axis")##	return im                                                               #modify running old version with pieces of the new version -- until I figure out what went wrong and have a complete copy                def net_plot(nrow,ncol,rx,cx,data,rlab,clab,outf,options_dictionary,pause_between_drawings=False):             #options_dictionary={}): #originally is was created here but used values from main.  Now, with entry, it can be created there (and             #hold things that were previously global.  (Global is now not easily defined).	#raw_input("top of net_plot")	#from Tkinter import *	global canvas	global forced_width	global forced_height        if 'draw_column_sequence' in options_dictionary:                draw_column_sequence=options_dictionary['draw_column_sequence']        else:                draw_column_sequence=False                                       	pp=Pidgin_plot()	pp.comment("Startup")	pp.comment("Options dictionary. Mostly irrelevant to plotting")	#pp.update_options(options_dictionary)	if 'font' in options_dictionary:  pp.options('font',options_dictionary['font'])		#for debugging:##	print "."*50##	print ".     for debugging     ......."##	print "."*50##	dk=options_dictionary.keys()##	dk.sort()##	for item in dk:##                print str(item),"\t",str(options_dictionary[item])				if not options_dictionary:                options_dictionary={}                	options_dictionary['fill_color']='black' #for lines and interiors of figures (Use common colors or '' for transparent)	options_dictionary['line_width']=1        #for lines	pp.options('fill_color','black')	pp.options('line_width',1)##	for item in pp.im:##                print item##        raw_input("1199")        			#pp.update_options(options_dictionary)        force_one_dim=False  #Kludge for 1 dim. Use both dims (same) for setup.  then draw only 1 (0 for other)	if options_dictionary['pairs_to_draw']:                pr=options_dictionary['pairs_to_draw']                if pr[0][0]==pr[0][1]:  force_one_dim=True		# QUESTION:  THE PROGRAM PARTIALLY IGNORES THE NEXT LINE IF I USE IT.  IT INSTANTIATES canvas, BUT IT IGNORES	#THE WIDTH AND HEIGHT	#canvas=Canvas(width="10.1i",height="7.5i",bg='white') #canvas , size in inches		forced_height=600	#forced_height=500	forced_width=1.2666*forced_height   # force aspect ratio of 10 by 7.5  (11 by 8.5 paper minus half inch margins  (1200        pp.options('forced_height_pixels',forced_height)        pp.options('forced_width_pixels',forced_width)        pp.options('forced_height_inches',forced_height/72.)        pp.options('forced_width_inches',forced_width/72.)	#canvas=Canvas(width=500,height=400,bg='white') #canvas , size in pixels##	try:##                canvas.pack_forget##        except:##                pass	try:                if canvas:                        canvas=""                        #raw_input("Canvas nulled")        except:                pass                	canvas=Canvas(width=forced_width,height=forced_height,bg='white') #canvas , size in pixels	canvas.pack(expand=YES,fill=BOTH)  #coordinates in pixels.  0,0 at upper left.  x increases left to right.  y increases high to low (upside down)		#print "test info:"	#print "height",canvas.winfo_height()	#print "width ",canvas.winfo_width()	#print tk.winfo_height()	#print tk.winfo_width()	#ODD:  If I remove the following raw input, then it does not correctly put the files in the folder.	#raw_input("700 by "+str(1.2666*700)+"? Press ENTER to continue.")  #PROBLEM:  It is returning  1   and   1    .	#print "700 by "+str(1.2666*700)+" #? Press ENTER to continue."  #PROBLEM:  It is returning  1   and   1    .		# Compute extremes that will be assigned to the graphical output.  Some of these will exceed	# empirical extremes.  This will make a square look like a square and allow labels to extend 	# to the right of the rightmost point and still be inside the graphical output.	cx_left,cx_right,cy_bottom,cy_top=outlrbt(nrow,ncol,rx,cx) # canvas left,...		true_left,true_right,true_bottom,true_top=lrbt(nrow,ncol,rx,cx)			#Put extremes computed for canvas into the canvas.	set_up(cx_left,cx_right,cy_bottom,cy_top)			#Grid	# For my applications the range is pretty reliably within +- 3.  Just mark integer grid	options_dictionary['line_width']=1	options_dictionary['fill_color']='lightblue'	pp.options('line_width',1)	pp.options('fill_color','lightblue')        #If the total range is small, less than 3, then impose a fine grid	#at .1's	if true_right-true_left<3 or true_top-true_bottom<3:                #raw_input("refine grid")                for h in arange(round(true_left-.049,1),round(true_right+.049,1),.1):                        line(h,true_top,h,true_bottom,"junk",options_dictionary)                        pp.line(h,true_top,h,true_bottom,"junk",options_dictionary)                for v in arange(round(true_bottom-.049,1),round(true_top+.049,1),.1):                        line(true_left,v,true_right,v,"junk",options_dictionary)                        pp.line(true_left,v,true_right,v,"junk",options_dictionary)        options_dictionary['fill_color']="#7777FF"  #somewhat darker blue        pp.options('fill_color',"#7777FF")  #somewhat darker blue                                                                              		for h in xrange(int(true_left-.5),int(true_right+.5)+1):		if h>=true_left and h<= true_right:                        line(h,true_top,h,true_bottom,"junk",options_dictionary)                        pp.line(h,true_top,h,true_bottom,"junk",options_dictionary)	for v in xrange(int(true_bottom-.6),int(true_top+.5)+1):                if v>=true_bottom and v<=true_top:                        line(true_left,v,true_right,v,"junk",options_dictionary)                        pp.line(true_left,v,true_right,v,"junk",options_dictionary)                                       			#Axes        pp.comment("Axes")                                       	options_dictionary['fill_color']='darkblue'	options_dictionary['line_width']=1		pp.options('fill_color','darkblue')	pp.options('line_width',1)		draw_axes(true_left,true_right,true_bottom,true_top,options_dictionary)        pp.line(true_left,0,true_right,0,"Axis",options_dictionary)        pp.line(0,true_bottom,0,true_top,"Axis",options_dictionary)	#line(true_left,0,true_right,0,"junk")	#line(0,true_bottom,0,true_top,"junk")										#OOPS -- grid is not looking squared:  check:	#options_dictionary['fill_color']='red'	#line(-1,1,1,1,'junk')	#line(1,1,1,-1,'junk')	#line(1,-1,-1,-1,'junk')	#line(-1,-1,-1,1,'junk')	#text_line(-1,1,"This should look square","junk")				#four line box  (Used for practice.  These could be replaced by drawing a box directly)	#options_dictionary['fill_color']='black'	#options_dictionary['line_width']=1	#line(cx_left,cy_top,cx_right,cy_top,"junk")	#line(cx_right,cy_top,cx_right,cy_bottom,"junk")	#line(cx_right,cy_bottom,cx_left,cy_bottom,"junk")	#line(cx_left,cy_bottom,cx_left,cy_top,"junk")				#text_line(0,0,str(nrow)+" rows "+str(ncol)+" columns","junk")		#draw lines first.  This puts them visually under everything else	options_dictionary['fill_color']=options_dictionary['line_color']   #global variable determined in main (default 'grey')	pp.options('fill_color',options_dictionary['line_color'])   #global variable determined in main (default 'grey')	#options_dictionary['line_width']=.1	options_dictionary['line_width']=.2	pp.options('line_width',.2)	if options_dictionary['draw_lines']:		for row in xrange(nrow):			begin_x=rx[row,0]			begin_y=rx[row,1]			for col in xrange(ncol):				if data[row,col]>0:					end_x=cx[col,0]					end_y=cx[col,1]					if not force_one_dim:                                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                                pp.line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                        else:                                                if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                line(m,begin_y,m,end_y,"link",options_dictionary)	                                                pp.line(m,begin_y,m,end_y,"link",options_dictionary)				#raw_input("RETURN to continue")			#draw locations of rows and name them	#print "\n\nfor debugging:  these items are presently associated with a color"	#ck=text_color_dictionary.keys()	#ck.sort()	#for cki in ck:  print cki,len(cki),	#print "\n\n"	nfound=0	nnotfound=0		for row in xrange(nrow):		options_dictionary['fill_color']='red' #'maroon'                pp.options('fill_color','red')		if options_dictionary['icons']:                        if not force_one_dim:                                triangle(rx[row,0],rx[row,1],"row_point",options_dictionary)                                pp.triangle(rx[row,0],rx[row,1],"row_point",options_dictionary)                                                        else:                                        if cx_left<0 and cx_right>0:                                        m=0                                else:                                                m=(cx_left+cx_right)/2                                triangle(m,rx[row,1],"row_point",options_dictionary)                                pp.triangle(m,rx[row,1],"row_point",options_dictionary)##                if 'row_heights' in options_dictionary:##                        #raw_input("at A, row_heights in options_dictionary")##                else:##                        #raw_input("at A,  row_heights NOT IN options_dictionary")                                        if 'row_heights' in options_dictionary:  #if it is in the dictionary                        if options_dictionary['row_heights']==True: #and not 'False' Mere presence in dict yields True                                print "row heights",options_dictionary['row_heights']                                raw_input("it thinks row_heights is in options_dictionary")                                if options_dictionary['row_heights']:                                        row_height_positive=[]                                        #raw_input("at b,")                                                                                if not force_one_dim:                                                height_rectangle(rx[row,0],rx[row,1],options_dictionary["row_heights"][rlab[row].strip()],"row_point",options_dictionary)                                                if options_dictionary["row_heights"][rlab[row].strip()]>0: row_height_positive.append(row)                                        else:                                                        if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                triangle(m,rx[row,1],"row_point",options_dictionary)                                                pp.triangle(m,rx[row,1],"row_point",options_dictionary)		#options_dictionary['fill_color']='darkred' #'maroon'		options_dictionary['fill_color']='black' #'for black and blue labels'		pp.options('fill_color','black') #'for black and blue labels'		#default='darkred'		default='black'		rlab_row=rlab[row].strip()		extra_info=[]				while "<" in rlab_row:			#print rlab_row,row			#raw_input("check for <")			left=rlab_row.index("<")			#print "rlab_row|"+rlab_row+"|"			#print "left",left			try:				right=rlab_row,index(">",left)  #??? this is not picking up a terminal '>'				ext=rlab_row[left+1:right]				#print "found right >",right    #??? 			except:				#right=len(rlab_row)				ext=rlab_row[left+1:len(rlab_row)-1]					#print "did not fine right >",right			rlab_row=rlab_row[:left].strip()								#ex=rlab_row[left+1:right]			#print "ex:  ",ex								if color_from_bracket:  extra_info.append(ext)			if color_from_name:extra_info.append(rlab_row)			print "extra_info:",extra_info						if len(extra_info)>0:				options_dictionary['fill_color']=default                                pp.options('fill_color',default)				for elt in extra_info:					#print "elt=",elt					#print "...dict",text_color_dictionary[elt]					if elt in text_color_dictionary:                                                options_dictionary['fill_color']=text_color_dictionary[elt]                                                pp.options('fill_color',text_color_dictionary[elt])						##		if options_dictionary['color_from_name']:  ##			rl=rlab_row.strip()##			rl=rl.upper()##			if rlab_row.strip().upper() in text_color_dictionary:##				#options_dictionary['fill_color']=text_color_dictionary[rlab_row.strip()]	##				options_dictionary['fill_color']=text_color_dictionary[rl]	##				nfound+=1			##			else:##				nnotfound+=1##				#not used##				#print "This label is not in the coloring instructions:  <"+rlab_row.strip()+"> length",len(rlab_row.strip()),nfound,"/",nnotfound####                                #removed from Eric version##				#print "This label is not in the coloring instructions:  <"+rl+"> length",len(rl),nfound,"/",nnotfound##				nnotfound+=1					if not force_one_dim:                                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                                pp.line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                                                                        else:                                                if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                line(m,begin_y,m,end_y,"link",options_dictionary)	                                                pp.line(m,begin_y,m,end_y,"link",options_dictionary)										if not force_one_dim:                        if 'row_heights' in options_dictionary:                                if options_dictionary['row_heights']==True:                                        if options_dictionary['row_heights']==True:                                                #raw_input("CCC")                                                restore_fill_color=options_dictionary['fill_color']                                                if row in row_height_positive:                                                        #raw_input("DDD")                                                        pp.comment('green')                                                        options_dictionary['fill_color']='#009900' #'green'                                                        pp.options('fill_color','#009900') #green                                                else:                                                        #raw_input("EEE")                                                        options_dictionary['fill_color']='red'                                                        pp.comment('red')                                                        pp.options('fill_color','red')                                                #raw_input("FFF")                                                        text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                                                pp.text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                                                options_dictionary['fill_color']=restore_fill_color                                                pp.comment("restore_fill_color")                                                pp.options('fill_color',restore_fill_color)                                else:                                                text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                                        pp.text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                else:                                if cx_left<0 and cx_right>0:                                m=0                        else:                                        m=(cx_left+cx_right)/2                        text_line(m,rx[row,1],rlab[row],"row_label",options_dictionary)                        pp.text_line(m,rx[row,1],rlab[row],"row_label",options_dictionary)                        		#triangle(rx[row,0],rx[row,1],"row_point")		##########FUDGE#TO DROP WORDS#############text_line(rx[row,0],rx[row,1],rlab_row,"row_label")	#print "\ndebugging color from labels:   Found ",nfound,"  not Found ",nnotfound,"\n"	if not options_dictionary['square_table']:		#draw locations of columns and name them		for col in xrange(ncol):			options_dictionary['fill_color']='green'			if options_dictionary['icons']==True:                                if not force_one_dim:                                        square(cx[col,0],cx[col,1],"col_point",options_dictionary)                                else:                                                if cx_left<0 and cx_right>0:                                                m=0                                        else:                                                        m=(cx_left+cx_right)/2.                                        square(m,cx[col,1],"col_point",options_dictionary)                                			options_dictionary['fill_color']='blue'  #avoid red/green color blindness			default='blue'			clab_col=clab[col].strip()			extra_info=[]						while "<" in clab_col:				left=clab_col.index("<")				try:					right=clab_col,index(">",left)  #??? this is not picking up a terminal '>'					ext=clab_col[left+1:right]				except:					ext=clab_col[left+1:len(clab_col)-1]						#print "did not fine right >",right				clab_col=clab_col[:left].strip()										extra_info.append(ext)				if len(extra_info)>0:					options_dictionary['fill_color']=default					for elt in extra_info:						if elt in text_color_dictionary:							options_dictionary['fill_color']=text_color_dictionary[elt]			                        if not force_one_dim:                                text_line(cx[col,0],cx[col,1],clab_col,"col_label",options_dictionary)                        else:                                        if cx_left<0 and cx_right>0:                                        m=0                                else:                                                m=(cx_left+cx_right)/2                                text_line(m,cx[col,1],clab_col,"col_label",options_dictionary)        if 'draw_column_sequence' in options_dictionary:                #print options_dictionary["draw_column_sequence"]                #raw_input("dcs in net_plot before drawing2")                    if options_dictionary['draw_column_sequence']:   #if True                                                #print type(options_dictionary["draw_column_sequence"])                        #raw_input("dcs in net_plot before drawing3")                            restore_fill_color=options_dictionary['fill_color']                        restore_line_width=options_dictionary['line_width']                        options_dictionary['fill_color']='dark blue'                        options_dictionary['line_width']=2.3                        #Try from deep green to light light, where light is the leading edge                        #cs=['#000000','#001100','#002200','#003300','#004400','#005500','#006600','#007700','#008800','#009900'] #10 brightness shade of green                        #Too many shades make it hard to select during Illustrator editing                        cs=['#AA0000','#666600','#00AA00']                         #stp=int(ncol/len(cs))                        conversion_slope=(len(cs)/float(ncol))                        for col in xrange(ncol-1):                                #print "col",col,"len(cs)",len(cs),"int(col*conversion_slope)",int(col*conversion_slope)                                options_dictionary['fill_color']=cs[int(col*conversion_slope)]                                ##switch to two colors, using green for last month (last 5 data points)                                #if col>=ncol-4:                                #        options_dictionary['fill_color']="#44BB00"                                #else:                                #        options_dictionary['fill_color']="#5555BB"                                begin_x=cx[col,0]                                begin_y=cx[col,1]                                end_x=cx[col+1,0]                                end_y=cx[col+1,1]                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                #print clab[col],clab[col+1]                        options_dictionary['fill_color']=restore_fill_color                        options_dictionary['line_width']=restore_line_width##	for item in pp.im:##                print item##        raw_input("1602")        	pp.save("meta_plot")        #print "before ps, file is",outf			#canvas.postscript(file=outf) #(file="rectangle_out"+str(pcount))        #raw_input("debug, filing"+outf)                        	canvas.postscript(file=outf,width=1.6*forced_width,height=1.25*forced_height,rotate=False,x=-.5*forced_width) #(file="rectangle_out"+str(pcount))	#sys.outf.flush()	#print "after ps"	#ppss=canvas.postscript()	#jk=open("junk","w")	#jk.write(ppss)	#print "Saving  'rectangle_out', a  postscript format output file."        #print "Saving  "+outf+", a  postscript format output file."        #time.sleep(10)        #raw_input("pause between drawings="+str(pause_between_drawings))        #time.sleep(5)        #print "*"        pause_between_drawings=True	if pause_between_drawings:                #time.sleep(15)                canvas.pack(expand=YES,fill=BOTH)  #coordinates in pixels.  0,0 at upper left.  x increases left to right.  y increases high to low (upside down)                canvas.update()                #print "*"*40  #It seems to want to go back to screen before producint the actual plot                #raw_input("WAIT for- image to be drawn.  Then press RETURN to contine to next image or to close the program.")                #time.sleep(5)        #Tcl.quit()        if options_dictionary['clean_up']:  #default                #print "cleanup-----------------------------------"                canvas.pack_forget()  #Why is this not leaving a momentarily blank screen?                canvas.destroy()                        def net_plotSAVEDduringrepair(nrow,ncol,rx,cx,data,rlab,clab,outf,options_dictionary,pause_between_drawings=False):             #options_dictionary={}): #originally is was created here but used values from main.  Now, with entry, it can be created there (and             #hold things that were previously global.  (Global is now not easily defined).	#raw_input("top of net_plot")	#from Tkinter import *	global canvas	global forced_width	global forced_height		if not options_dictionary:                options_dictionary={}	options_dictionary['fill_color']='black' #for lines and interiors of figures (Use common colors or '' for transparent)	options_dictionary['line_width']=1        #for lines        force_one_dim=False  #Kludge for 1 dim. Use both dims (same) for setup.  then draw only 1 (0 for other)	if options_dictionary['pairs_to_draw']:                pr=options_dictionary['pairs_to_draw']                if pr[0][0]==pr[0][1]:  force_one_dim=True		# QUESTION:  THE PROGRAM PARTIALLY IGNORES THE NEXT LINE IF I USE IT.  IT INSTANTIATES canvas, BUT IT IGNORES	#THE WIDTH AND HEIGHT	#canvas=Canvas(width="10.1i",height="7.5i",bg='white') #canvas , size in inches		#forced_height=700	forced_height=500	forced_width=1.2666*forced_height   # force aspect ratio of 10 by 7.5  (11 by 8.5 paper minus half inch margins  (1200	#canvas=Canvas(width=500,height=400,bg='white') #canvas , size in pixels##	try:##                canvas.pack_forget##        except:##                pass	try:                if canvas:                        canvas=""                        #raw_input("Canvas nulled")        except:                pass                	canvas=Canvas(width=forced_width,height=forced_height,bg='white') #canvas , size in pixels	canvas.pack(expand=YES,fill=BOTH)  #coordinates in pixels.  0,0 at upper left.  x increases left to right.  y increases high to low (upside down)		#print "test info:"	#print "height",canvas.winfo_height()	#print "width ",canvas.winfo_width()	#print tk.winfo_height()	#print tk.winfo_width()	#ODD:  If I remove the following raw input, then it does not correctly put the files in the folder.	#raw_input("700 by "+str(1.2666*700)+"? Press ENTER to continue.")  #PROBLEM:  It is returning  1   and   1    .	#print "700 by "+str(1.2666*700)+" #? Press ENTER to continue."  #PROBLEM:  It is returning  1   and   1    .		# Compute extremes that will be assigned to the graphical output.  Some of these will exceed	# empirical extremes.  This will make a square look like a square and allow labels to extend 	# to the right of the rightmost point and still be inside the graphical output.	cx_left,cx_right,cy_bottom,cy_top=outlrbt(nrow,ncol,rx,cx) # canvas left,...		true_left,true_right,true_bottom,true_top=lrbt(nrow,ncol,rx,cx)			#Put extremes computed for canvas into the canvas.	set_up(cx_left,cx_right,cy_bottom,cy_top)			#Grid	# For my applications the range is pretty reliably within +- 3.  Just mark integer grid	options_dictionary['line_width']=1	options_dictionary['fill_color']='lightblue'        #If the total range is small, less than 3, then impose a fine grid	#at .1's        #print "true_right,true_left",true_right,true_left        #print "true_top,true_bottom",true_top,true_bottom	if true_right-true_left<3:                #raw_input("refine grid")                for h in xrange(10*int(true_left-.5),10*int(true_right+.5)+1):                        if h/10.>=true_left and h/10.<= true_right:                                line(h/10.,true_top,h/10.,true_bottom,"junk",options_dictionary)                for v in xrange(int(10*(true_bottom-.6)),int(10*true_top+.5)):                                                                                     if v/10.>=true_bottom and v/10.<=true_top+.1:                                line(true_left,v/10.,true_right,v/10.,"junk",options_dictionary)        options_dictionary['fill_color']="#7777FF"  #somewhat darker blue     		for h in xrange(int(true_left-.5),int(true_right+.5)+1):		if h>=true_left and h<= true_right: line(h,true_top,h,true_bottom,"junk",options_dictionary)	for v in xrange(int(true_bottom-.6),int(true_top+.5)+1):                if v>=true_bottom and v<=true_top:                        line(true_left,v,true_right,v,"junk",options_dictionary)			#Axes	options_dictionary['fill_color']='darkblue'	options_dictionary['line_width']=1		draw_axes(true_left,true_right,true_bottom,true_top,options_dictionary)	#line(true_left,0,true_right,0,"junk")	#line(0,true_bottom,0,true_top,"junk")										#OOPS -- grid is not looking squared:  check:	#options_dictionary['fill_color']='red'	#line(-1,1,1,1,'junk')	#line(1,1,1,-1,'junk')	#line(1,-1,-1,-1,'junk')	#line(-1,-1,-1,1,'junk')	#text_line(-1,1,"This should look square","junk")				#four line box  (Used for practice.  These could be replaced by drawing a box directly)	#options_dictionary['fill_color']='black'	#options_dictionary['line_width']=1	#line(cx_left,cy_top,cx_right,cy_top,"junk")	#line(cx_right,cy_top,cx_right,cy_bottom,"junk")	#line(cx_right,cy_bottom,cx_left,cy_bottom,"junk")	#line(cx_left,cy_bottom,cx_left,cy_top,"junk")				#text_line(0,0,str(nrow)+" rows "+str(ncol)+" columns","junk")		#draw lines first.  This puts them visually under everything else	options_dictionary['fill_color']=options_dictionary['line_color']   #global variable determined in main (default 'grey')	#options_dictionary['line_width']=.1	options_dictionary['line_width']=.2	if options_dictionary['draw_lines']:		for row in xrange(nrow):			begin_x=rx[row,0]			begin_y=rx[row,1]			for col in xrange(ncol):				if data[row,col]>0:					end_x=cx[col,0]					end_y=cx[col,1]					if not force_one_dim:                                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                        else:                                                if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                line(m,begin_y,m,end_y,"link",options_dictionary)				#raw_input("RETURN to continue")			#draw locations of rows and name them	#print "\n\nfor debugging:  these items are presently associated with a color"	#ck=text_color_dictionary.keys()	#ck.sort()	#for cki in ck:  print cki,len(cki),	#print "\n\n"	nfound=0	nnotfound=0		for row in xrange(nrow):		options_dictionary['fill_color']='red' #'maroon'		if options_dictionary['icons']:                        if not force_one_dim:                                triangle(rx[row,0],rx[row,1],"row_point",options_dictionary)                        else:                                        if cx_left<0 and cx_right>0:                                        m=0                                else:                                                m=(cx_left+cx_right)/2                                triangle(m,rx[row,1],"row_point",options_dictionary)##                if 'row_heights' in options_dictionary:##                        #raw_input("at A, row_heights in options_dictionary")##                else:##                        #raw_input("at A,  row_heights NOT IN options_dictionary")                                        if 'row_heights' in options_dictionary:  #if it is in the dictionary                        if options_dictionary['row_heights']==True: #and not 'False' Mere presence in dict yields True                                print "row heights",options_dictionary['row_heights']                                raw_input("it thinks row_heights is in options_dictionary")                                if options_dictionary['row_heights']:                                        row_height_positive=[]                                        #raw_input("at b,")                                                                                if not force_one_dim:                                                height_rectangle(rx[row,0],rx[row,1],options_dictionary["row_heights"][rlab[row].strip()],"row_point",options_dictionary)                                                if options_dictionary["row_heights"][rlab[row].strip()]>0: row_height_positive.append(row)                                        else:                                                        if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                triangle(m,rx[row,1],"row_point",options_dictionary)		options_dictionary['fill_color']='darkred' #'maroon'		default='darkred'		rlab_row=rlab[row].strip()		extra_info=[]				while "<" in rlab_row:			#print rlab_row,row			#raw_input("check for <")			left=rlab_row.index("<")			#print "rlab_row|"+rlab_row+"|"			#print "left",left			try:				right=rlab_row,index(">",left)  #??? this is not picking up a terminal '>'				ext=rlab_row[left+1:right]				#print "found right >",right    #??? 			except:				#right=len(rlab_row)				ext=rlab_row[left+1:len(rlab_row)-1]					#print "did not fine right >",right			rlab_row=rlab_row[:left].strip()								#ex=rlab_row[left+1:right]			#print "ex:  ",ex								if color_from_bracket:  extra_info.append(ext)			if color_from_name:extra_info.append(rlab_row)			print "extra_info:",extra_info						if len(extra_info)>0:				options_dictionary['fill_color']=default				for elt in extra_info:					#print "elt=",elt					#print "...dict",text_color_dictionary[elt]					if elt in text_color_dictionary:						options_dictionary['fill_color']=text_color_dictionary[elt]						##		if options_dictionary['color_from_name']:  ##			rl=rlab_row.strip()##			rl=rl.upper()##			if rlab_row.strip().upper() in text_color_dictionary:##				#options_dictionary['fill_color']=text_color_dictionary[rlab_row.strip()]	##				options_dictionary['fill_color']=text_color_dictionary[rl]	##				nfound+=1			##			else:##				nnotfound+=1##				#not used##				#print "This label is not in the coloring instructions:  <"+rlab_row.strip()+"> length",len(rlab_row.strip()),nfound,"/",nnotfound####                                #removed from Eric version##				#print "This label is not in the coloring instructions:  <"+rl+"> length",len(rl),nfound,"/",nnotfound##				nnotfound+=1					if not force_one_dim:                                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                        else:                                                if cx_left<0 and cx_right>0:                                                        m=0                                                else:                                                                m=(cx_left+cx_right)/2                                                line(m,begin_y,m,end_y,"link",options_dictionary)										if not force_one_dim:                        if 'row_heights' in options_dictionary:                                if options_dictionary['row_heights']==True:                                        if options_dictionary['row_heights']==True:                                                #raw_input("CCC")                                                restore_fill_color=options_dictionary['fill_color']                                                if row in row_height_positive:                                                        #raw_input("DDD")                                                        options_dictionary['fill_color']='#009900' #'green'                                                else:                                                        #raw_input("EEE")                                                        options_dictionary['fill_color']='red'                                                #raw_input("FFF")                                                        text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                                                options_dictionary['fill_color']=restore_fill_color                                else:                                                text_line(rx[row,0],rx[row,1],rlab[row],"row_label",options_dictionary)                else:                                if cx_left<0 and cx_right>0:                                m=0                        else:                                        m=(cx_left+cx_right)/2                        text_line(m,rx[row,1],rlab[row],"row_label",options_dictionary)                        		#triangle(rx[row,0],rx[row,1],"row_point")		##########FUDGE#TO DROP WORDS#############text_line(rx[row,0],rx[row,1],rlab_row,"row_label")	#print "\ndebugging color from labels:   Found ",nfound,"  not Found ",nnotfound,"\n"	if not options_dictionary['square_table']:		#draw locations of columns and name them		for col in xrange(ncol):			options_dictionary['fill_color']='green'			if options_dictionary['icons']==True:                                if not force_one_dim:                                        square(cx[col,0],cx[col,1],"col_point",options_dictionary)                                else:                                                if cx_left<0 and cx_right>0:                                                m=0                                        else:                                                        m=(cx_left+cx_right)/2                                        square(m,cx[col,1],"col_point",options_dictionary)                                			options_dictionary['fill_color']='blue'  #avoid red/green color blindness			default='blue'			clab_col=clab[col].strip()			extra_info=[]						while "<" in clab_col:				left=clab_col.index("<")				try:					right=clab_col,index(">",left)  #??? this is not picking up a terminal '>'					ext=clab_col[left+1:right]				except:					ext=clab_col[left+1:len(clab_col)-1]						#print "did not fine right >",right				clab_col=clab_col[:left].strip()										extra_info.append(ext)				if len(extra_info)>0:					options_dictionary['fill_color']=default					for elt in extra_info:						if elt in text_color_dictionary:							options_dictionary['fill_color']=text_color_dictionary[elt]			                        if not force_one_dim:                                text_line(cx[col,0],cx[col,1],clab_col,"col_label",options_dictionary)                        else:                                        if cx_left<0 and cx_right>0:                                        m=0                                else:                                                m=(cx_left+cx_right)/2                                text_line(m,cx[col,1],clab_col,"col_label",options_dictionary)        if 'draw_column_sequence' in options_dictionary:                #print options_dictionary["draw_column_sequence"]                #raw_input("dcs in net_plot before drawing2")                    if options_dictionary['draw_column_sequence']:                                                #print type(options_dictionary["draw_column_sequence"])                        #raw_input("dcs in net_plot before drawing3")                            restore_fill_color=options_dictionary['fill_color']                        restore_line_width=options_dictionary['line_width']                        options_dictionary['fill_color']='dark blue'                        options_dictionary['line_width']=2.3                        #Try from deep green to light light, where light is the leading edge                        #cs=['#000000','#001100','#002200','#003300','#004400','#005500','#006600','#007700','#008800','#009900'] #10 brightness shade of green                        #Too many shades make it hard to select during Illustrator editing                        cs=['#AA0000','#666600','#00AA00']                         #stp=int(ncol/len(cs))                        conversion_slope=(len(cs)/float(ncol))                        for col in xrange(ncol-1):                                #print "col",col,"len(cs)",len(cs),"int(col*conversion_slope)",int(col*conversion_slope)                                options_dictionary['fill_color']=cs[int(col*conversion_slope)]                                ##switch to two colors, using green for last month (last 5 data points)                                #if col>=ncol-4:                                #        options_dictionary['fill_color']="#44BB00"                                #else:                                #        options_dictionary['fill_color']="#5555BB"                                begin_x=cx[col,0]                                begin_y=cx[col,1]                                end_x=cx[col+1,0]                                end_y=cx[col+1,1]                                line(begin_x,begin_y,end_x,end_y,"link",options_dictionary)                                #print clab[col],clab[col+1]                        options_dictionary['fill_color']=restore_fill_color                        options_dictionary['line_width']=restore_line_width		        #print "before ps, file is",outf			#canvas.postscript(file=outf) #(file="rectangle_out"+str(pcount))        #raw_input("debug, filing"+outf)                        	canvas.postscript(file=outf,width=1.6*forced_width,height=1.25*forced_height,rotate=False,x=-.5*forced_width) #(file="rectangle_out"+str(pcount))	#sys.outf.flush()	#print "after ps"	#ppss=canvas.postscript()	#jk=open("junk","w")	#jk.write(ppss)	#print "Saving  'rectangle_out', a  postscript format output file."        #print "Saving  "+outf+", a  postscript format output file."        #time.sleep(10)        #raw_input("pause between drawings="+str(pause_between_drawings))        #time.sleep(5)        #print "*"        pause_between_drawings=True	if pause_between_drawings:                #time.sleep(15)                canvas.pack(expand=YES,fill=BOTH)  #coordinates in pixels.  0,0 at upper left.  x increases left to right.  y increases high to low (upside down)                canvas.update()                #print "*"*40  #It seems to want to go back to screen before producint the actual plot                #raw_input("WAIT for- image to be drawn.  Then press RETURN to contine to next image or to close the program.")                #time.sleep(5)        #Tcl.quit()        if options_dictionary['clean_up']:  #default                #print "cleanup-----------------------------------"                canvas.pack_forget()  #Why is this not leaving a momentarily blank screen?                canvas.destroy()        	def read_text_color_dictionary(text_color_file_name):	text_color_file=open(text_color_file_name,"r")	lines=text_color_file.readlines()	if len(lines)==1:		countr=lines[0].count("\r")		countn=lines[0].count("\n")		countrn=lines[0].count("\r\n")		if countrn>=countr and countrn>countn:			splitter="\r\n"		elif countr>countn:			splitter="\r"		else:			splitter="\n"		new_lines=lines[0].split(splitter)		lines=new_lines								print """possible error in color file.  It was read as one line.  This may be correct.  More likely		it is an error generated by moving the text file from PC to Mac.  The move creates errors in 'invisible'		end of line characters."""		text_color_dictionary={}	for line in lines:		line=line.strip()		if len(line)>0:			try:				c=line.index(":")			except:				print "error in file <"+text_color_file_name+">"				print "this line shows no colon:"				print line				raw_input("please stop and fix the file")				k=line[:c].strip()			v=line[c+1:].strip()			kk=k.upper()			text_color_dictionary[kk]=v				return text_color_dictionary	#Graphics Set up for running when I've already got an array (bypassing a file)def rectangle_driver_setup_mat006(nrow,ncol,ndim,rx,cx,data,rlab,clab,name_to_file,options_dictionary):##        kk=options_dictionary.keys()##        kk.sort()##        for k in kk:##                print k,options_dictionary[k]##        raw_input("1check pause")                #I want to fun graphics during the optimization.  This should        #send the numbers (without filing them), and set up options        #if all or none of the options are set, this will insert defaults                if "data_file" not in options_dictionary: options_dictionary["data_file"]=name_to_file        if "text_color_file_name" not in options_dictionary: options_dictionary["text_color_file_name"]="MHMH colors.txt"        if "color_from_bracket" not in options_dictionary: options_dictionary["color_from_bracket"]=False        if "color_from_bracket" not in options_dictionary: options_dictionary["color_from_bracket"]=False        if "color_from_name" not in options_dictionary: options_dictionary["color_from_name"]=True        if "square_table" not in options_dictionary: options_dictionary["square_table"]=False        if "icons" not in options_dictionary: options_dictionary["icons"]=False        if "draw_lines" not in options_dictionary: options_dictionary["draw_lines"]=True        if "draw_column_sequence" not in options_dictionary:                options_dictionary["draw_column_sequence"]=False        else:                                if options_dictionary["draw_column_sequence"]==True:                        options_dictionary["draw_column_sequence"]=True                else:                        options_dictionary["draw_column_sequence"]=False                                if "display_ndim" not in options_dictionary: options_dictionary["display_ndim"]=2        if "pairs_to_draw" not in options_dictionary: options_dictionary["pairs_to_draw"]=[[0,1]]        if "line_color" not in options_dictionary: options_dictionary["line_color"]='grey'        if "clean_up" not in options_dictionary: options_dictionary["clean_up"]=True        rectangle_driver_action_mat006(nrow,ncol,ndim,rx,cx,                                data,rlab,clab,options_dictionary)def rectangle_driver_entry(root="run080823mat",        text_color_file_name="MHMH colors.txt",        color_from_bracket=False,  #(search for colors within text enclosed in <  and > brackets        color_from_name=True,   #(search for colors associated with a direct match to the name)        square_table=False,        icons=False,        draw_lines=True,        line_color='grey',         #Change to suit.  Follow color guide at top of this program file.         display_ndim=2,        pairs_to_draw=[[0,1]],    #Select pairs of dimensions to be plotted (i.e., not all pairs)        pause_between_drawings=False,        clean_up=True,        row_heights=False,        draw_column_sequence=False,        font=("Helvetica",12,"normal")):        print "debugging at top of rectangle_driver_entry in 007.  "        print "draw_column_sequence=",draw_column_sequence        raw_input('debug draw_column_sequence')        #raw_input("root"+root)        options_dictionary={}        options_dictionary["data_file"]=root        options_dictionary["text_color_file_name"]=text_color_file_name        options_dictionary["color_from_bracket"]=color_from_bracket        options_dictionary["color_from_name"]=color_from_name        options_dictionary["square_table"]=square_table        options_dictionary["icons"]=icons        options_dictionary["draw_lines"]=draw_lines        options_dictionary["display_ndim"]=display_ndim        options_dictionary["pairs_to_draw"]=pairs_to_draw        options_dictionary["line_color"]=line_color        options_dictionary["pause_between_drawings"]=pause_between_drawings        options_dictionary["clean_up"]=clean_up        options_dictionary["row_heights"]=row_heights        options_dictionary["draw_column_sequence"]=draw_column_sequence        options_dictionary["font"]=font        #raw_input("pause_between_drawings aaa"+str(pause_between_drawings))        print "file received is ",options_dictionary["data_file"]        #raw_input("AA")        #Here and somewhere else I'm doing a temporary bypass        #if text_color_file_name!="NONE":        #        text_color_dictionary=read_text_color_dictionary(text_color_file_name)        text_color_dictionary={}##        # Optional color labels:####        #    If you have a file like Max's "text_color", insert its name here.  If not, then leave the name as "NONE"  (upper case)##        #text_color_file_name="NONE"##        #text_color_file_name="text_color"##        #text_color_file_name="morph colors.txt"##        text_color_file_name="MHMH colors.txt" #       color_from_bracket=False  #(search for colors within text enclosed in <  and > brackets #       color_from_name=True   #(search for colors associated with a direct match to the name)##        #See note at the beginning of this program file describing color.  See Max's text_color file for an example        ##         #At present, as read, the first line is:"""        try:                print "data_file is",options_dictionary['data_file']                #raw_input("at A")                nrow,ncol,data,rlab,clab=readface(options_dictionary['data_file'])                #print clab                ###raw_input("Press RETURN to continue")                print "Data file opened.  It has ",nrow," rows and ",ncol," columns."        except:                                print """        Unable to make sense of the data file.  The first line should specify the number of rows.        The second line should specify the number of columns.  The next 'nrow' lines should be        the data for those lines.  The next 'nrow' lines should be labels for those rows.  The        next 'ncol' lines should be labels for those columns.          At present, as read, the first line is:"""                #raw_input("at B")                junk=open(options_dictionary['data_file'])                junkline=junk.readline()                print junkline        #  Add on's:        options_dictionary["nrow"]=nrow        options_dictionary["ncol"]=ncol        ##        # SQUARE versus RECTANGLE####        #  if the table is really square, such that it is plotting row i and column i at the same place with the same label, then##        # remove the 'comment' symbol from the line  'square_table=True'   Otherwise, it will use the code square=False##        square_table=False##        #square_table=True##        options_dictionary["square_table"]=square_table######        #  Turn Icons On or Off####        # One of the following two lines should NOT begin with a comment symbol, #####        icons=True##        #icons=False##        options_dictionary["icons"]=icons######        #  Turn Lines On or Off####        # One of the following two lines should NOT begin with a comment symbol, #####        draw_lines=True##        #draw_lines=False##        options_dictionary["draw_lines"]=draw_lines########        # Custom color for lines####        line_color='grey'         #Change to suit.  Follow color guide at top of this program file.    ##        options_dictionary["line_color"]=line_color##                              # ---------------        #      Read the DwV output coordinate file        # ---------------                                #raw_input("BB")        #This is reading the coordinate file into lines and then sending the lines to an extractor for specific sets        #Would be cleaner to just open it again for each specific set.  (That is similar to the way I read the data-link file.)        coord_file_name=options_dictionary['data_file']+"a"        cf=open(coord_file_name,"r")        clines=cf.readlines()        for i in range(len(clines)):                clines[i]=clines[i].replace(",","")                clines[i]=clines[i].strip()        #nrow,ncol,data,rlab,clab=readface(data_file)        rx,ndim=readcoord("row_coordinates",nrow,clines)        try:            cx,ndim=readcoord("column_coordinates",ncol,clines)        except:                cx,ndim=readcoord("col_coordinates",ncol,clines)        cf.close()        # ---------------        #      Prepare to plot        # ---------------##        kk=options_dictionary.keys()##        kk.sort()##        for k in kk:##                print k,options_dictionary[k]##        raw_input("2check pause")                rectangle_driver_action_mat006(nrow,ncol,ndim,rx,cx,                                data,rlab,clab,options_dictionary)def rectangle_driver_action_mat006(nrow,ncol,ndim,rx,cx,                                data,rlab,clab,options_dictionary):##        kk=options_dictionary.keys()##        kk.sort()##        for k in kk:##                print k,options_dictionary[k]##        raw_input("2check pause")                #ncol=5        display_ndim=2        #("got to action")        pause_between_drawings=options_dictionary['pause_between_drawings']                #if not options_dictionary['pairs_to_draw']:        od=options_dictionary['pairs_to_draw']        if str(type(od))=="<type 'str'>" and od.upper()=="ALL":                for horizontal in range(ndim):                        for vertical in range(horizontal,ndim):                                print "horizontal, vertical",horizontal,vertical                                rxflat=zeros((nrow,2),float)                                cxflat=zeros((ncol,2),float)                                rxflat[0:nrow,0]=rx[0:nrow,0]                                rxflat[0:nrow,1]=rx[0:nrow,vertical]                                cxflat[0:ncol,0]=cx[0:ncol,0]                                cxflat[0:ncol,1]=cx[0:ncol,vertical]                                                                        file_name=options_dictionary['data_file']+str(horizontal+1)+"x"+str(vertical+1)+".ps"                                raw_input("2269 calling net_plot with draw_column_sequence="+str(options_dictionary['draw_column_sequence']))                                net_plot(nrow,ncol,rxflat,cxflat,data,rlab,clab,file_name,options_dictionary,pause_between_drawings=pause_between_drawings)        else:                pairs_of_dimensions=options_dictionary['pairs_to_draw']                for pair in pairs_of_dimensions:                        horizontal=pair[0]                        vertical=pair[1]                                                rxflat=zeros((nrow,2),float)                        cxflat=zeros((ncol,2),float)                        rxflat[0:nrow,0]=rx[0:nrow,0]                        rxflat[0:nrow,1]=rx[0:nrow,vertical]                                                cxflat[0:ncol,0]=cx[0:ncol,0]                        cxflat[0:ncol,1]=cx[0:ncol,vertical]                                                                file_name=options_dictionary['data_file']+str(horizontal+1)+"x"+str(vertical+1)+".ps"                        net_plot(nrow,ncol,rxflat,cxflat,data,rlab,clab,file_name,options_dictionary,pause_between_drawings=pause_between_drawings)                                                                #                #canvas.pack_forget()        #raw_input("Complete")		                     # ------------------------------------------------------------------if __name__=="__main__":                        # ------------------------------------------------        # ---   Driver:    Makes up some dat and labels.  Sends to netplot.   ---        # ------------------------------------------------			        print "="*50        #print "For development build random data (to be graphed):"        #nrow=100        #import sys        #sys.path.append("/Python-2.3.4/Numeric")        # ---------------        #      Read the face format data file        # ---------------        from tkFileDialog import askopenfilename  	#get standard dialogs        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        options_dictionary={} #replacing global        #  Data file        #  Enter data file by typing it in here.  It will find the data<a> file automatically        if 1==0:   #normal                 data_file=askopenfilename()        else:   # for debugging                #===================================================================================                #data_file="face1CC00_4"	   #E N T E R   FILENAME HERE.  THE DATA FILE, NOT THE "a-file" ****************                #data_file="1052.txt"	   #E N T E R   FILENAME HERE.  THE DATA FILE, NOT THE "a-file" ****************                #data_file="facemat1b"	   #E N T E R   FILENAME HERE.  THE DATA FILE, NOT THE "a-file" ****************                #data_file="Social Net186x234mtx"	   #E N T E R   FILENAME HERE.  THE DATA FILE, NOT THE "a-file" ****************                #data_file="Repmin1_135X1430"                data_file="run080823mat"   # <<===============  CHANGE THIS                #===================================================================================                options_dictionary["data_file"]=data_file        # Optional color labels:        #    If you have a file like Max's "text_color", insert its name here.  If not, then leave the name as "NONE"  (upper case)        #text_color_file_name="NONE"        #text_color_file_name="text_color"        #text_color_file_name="morph colors.txt"        text_color_file_name="MHMH colors.txt"        color_from_bracket=False  #(search for colors within text enclosed in <  and > brackets        color_from_name=True   #(search for colors associated with a direct match to the name)                options_dictionary["text_color_file_name"]=text_color_file_name        options_dictionary["color_from_bracket"]=color_from_bracket        options_dictionary["color_from_name"]=color_from_name        options_dictionary["clean_up"]=True             #See note at the beginning of this program file describing color.  See Max's text_color file for an example        #===================================================================================        #  Add on's:        # SQUARE versus RECTANGLE        #  if the table is really square, such that it is plotting row i and column i at the same place with the same label, then        # remove the 'comment' symbol from the line  'square_table=True'   Otherwise, it will use the code square=False        square_table=False        #square_table=True        options_dictionary["square_table"]=square_table        #  Turn Icons On or Off        # One of the following two lines should NOT begin with a comment symbol, #        icons=True        #icons=False        options_dictionary["icons"]=icons        #  Turn Lines On or Off        # One of the following two lines should NOT begin with a comment symbol, #        draw_lines=True        #draw_lines=False        options_dictionary["draw_lines"]=draw_lines        # Custom color for lines        line_color='grey'         #Change to suit.  Follow color guide at top of this program file.            options_dictionary["line_color"]=line_color        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        #Restore this to be optional within either user's file or the software file        #if text_color_file_name!="NONE":        #        text_color_dictionary=read_text_color_dictionary(text_color_file_name)        #        print text_color_dictionary        text_color_dictionary={} #place holder                        #	        #print data_file        #data_file="t1_5M5462x20"        #print data_file        try:                print "data_file is",data_file                nrow,ncol,data,rlab,clab=readface(data_file)                #print clab                ###raw_input("Press RETURN to continue")                print "Data file opened.  It has ",nrow," rows and ",ncol," columns."        except:                print """        Unable to make sense of the data file.  The first line should specify the number of rows.        The second line should specify the number of columns.  The next 'nrow' lines should be        the data for those lines.  The next 'nrow' lines should be labels for those rows.  The        next 'ncol' lines should be labels for those columns.          At present, as read, the first line is:"""                junk=open(data_file)                junkline=junk.readline()                print junkline        options_dictionary["nrow"]=nrow        options_dictionary["ncol"]=ncol                                                # ---------------        #      Read the DwV output coordinate file        # ---------------                                #This is reading the coordinate file into lines and then sending the lines to an extractor for specific sets        #Would be cleaner to just open it again for each specific set.  (That is similar to the way I read the data-link file.)        coord_file_name=data_file+"a"        cf=open(coord_file_name,"r")        clines=cf.readlines()        for i in range(len(clines)):                clines[i]=clines[i].replace(",","")                clines[i]=clines[i].strip()        #nrow,ncol,data,rlab,clab=readface(data_file)        rx,ndim=readcoord("row_coordinates",nrow,clines)        try:            cx,ndim=readcoord("column_coordinates",ncol,clines)        except:                cx,ndim=readcoord("col_coordinates",ncol,clines)        cf.close()        # ---------------        #      Prepare to plot        # ---------------        #ncol=5        display_ndim=2        for horizontal in range(ndim):                for vertical in range(horizontal,ndim):                        rxflat=zeros((nrow,2),float)                        cxflat=zeros((ncol,2),float)                        rxflat[0:nrow,0]=rx[0:nrow,0]                        rxflat[0:nrow,1]=rx[0:nrow,vertical]                        cxflat[0:ncol,0]=cx[0:ncol,0]                        cxflat[0:ncol,1]=cx[0:ncol,vertical]                                                        file_name=data_file+str(horizontal+1)+"x"+str(vertical+1)+".ps"                                                net_plot(nrow,ncol,rxflat,cxflat,data,rlab,clab,file_name,options_dictionary,pause_between_drawings=True)		                        #canvas.pack_forget()        raw_input("Complete")		